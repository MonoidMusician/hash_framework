import sqlite3, json
import hash_framework as hf
import png

JSON="/tmp/graph2.json"

def write_data():
    q = "SELECT DISTINCT "
    q += ','.join(map(lambda x: 'ri' + str(x), range(48)))
    q += ' FROM c_md4 WHERE tag LIKE "%schlaffers%";'
    print(q)

    db = sqlite3.connect("/home/cipherboy/framework_results.db")
    curr = db.cursor()
    data = curr.execute(q).fetchall()

    algo = hf.algorithms.md4()

    wangs_base = ['................................', '.........................*......', '.....................*..*.......', '......*.........................', '................................', '..................*.............', '..........****..................', '.................***............', '...............*................', '......*..****...................', '..*.............................', '*...............................', '......*..*......................', '..**.*..........................', '................................', '.............*..................', '*..*.**.........................', '................................', '................................', '*.*.............................', '*.**............................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '*...............................', '*...............................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................']
    sasakis_base = ['*.............................**', '......................*.*.......', '....................*...........', '..........***...................', '.......***............*******...', '*..........***..................', '*......***............*********.', '................................', '......*.**......................', '***.***............*............', '...................*............', '...................*............', '..**..*.........................', '................................', '................................', '*...............................', '...*............................', '................................', '................................', '................................', '*...............................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '*...............................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................']
    kasselman_base = ['................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '********************************', '................................', '...*...............*............', '...................*...........*', '................................', '................................', '..........................*.....', '......*.........................', '................................', '................................', '.................*..............', '.........................*......', '................................', '................................', '........*.......................', '............*...................', '................................', '................................', '...............................*', '...............................*', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................']
    dobbertins_base = ['................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '********************************', '................................', '...*...............*............', '...................*...........*', '................................', '................................', '..........................*.....', '......*.........................', '................................', '................................', '.................*..............', '.........................*......', '................................', '............*...................', '........*.......................', '............*...................', '................................', '................................', '...............................*', '...............................*', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................']
    schlaffers_base = ['................................', '.........................*......', '.....................*..*.......', '......*.........................', '................................', '...............****.............', '........***..*..................', '...................*.*..........', '.....**.....*...................', '........****....................', '..*.............................', '*.*............................*', '..**..*..*.**...................', '................................', '................................', '............**.*................', '*..*..*.........................', '................................', '................................', '*...............................', '*..*............................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '*...............................', '*...............................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................', '................................']

    bases = {
        'wangs': tuple(wangs_base),
        'sasakis': tuple(sasakis_base),
        'kasselmans': tuple(kasselman_base),
        'dobbertins': tuple(dobbertins_base),
        'schlaffers': tuple(schlaffers_base)
    }

    distances = [0] * len(data)
    edges = {}
    for i in range(0, len(data)):
        edges[i] = set()
        d1 = data[i]
        distances[i] = len(hf.attacks.collision.metric.loose.delta_alt(48, d1, bases['schlaffers']))
        for j in range(0, len(data)):
            d2 = data[j]
            dist = len(hf.attacks.collision.metric.loose.delta_alt(48, d1, d2))
            if dist == 1:
                edges[i].add(j)

    for i in range(0, len(data)):
        edges[i] = list(edges[i])

    indices = {}
    for k in bases:
        if bases[k] in data:
            indices[k] = data.index(bases[k])

    obj = {}
    obj['data'] = data
    obj['edges'] = edges
    obj['bases'] = bases
    obj['indices'] = indices
    obj['distances'] = distances

    f = open(, 'w')
    json.dump(obj, f)
    f.flush()
    f.close()

def max_radius():
    f = open(JSON, 'r')
    obj = json.load(f)
    f.close()

    data = obj['data']
    edges = obj['edges']
    bases = obj['bases']
    indices = obj['indices']
    distances = obj['distances']

    nedges = {}
    for k in edges:
        nedges[int(k)] = edges[k]
    edges = nedges

    print(edges[0])
    print(min(distances))
    print(max(distances))


    # Inefficient; can do in two runs.
    pmdist = 0
    pmds = 0
    for start in range(0, len(data)):
        pdist = [9999]*len(data)
        pdist[start] = 0
        pq = []
        pq.append(start)

        while len(pq) > 0:
            u = pq[0]
            pq = pq[1:]
            for v in edges[u]:
                d_v = pdist[u] + 1
                if d_v < pdist[v]:
                    pdist[v] = d_v
                    pq.append(v)

        lpmdist = max(pdist)
        if lpmdist > pmdist:
            print((lpmdist, start))
            pmdist = lpmdist
            pmds = start
    print((pmdist, pmds))

def find_longest_path():
    f = open(JSON, 'r')
    obj = json.load(f)
    f.close()

    data = obj['data']
    edges = obj['edges']
    bases = obj['bases']
    indices = obj['indices']
    distances = obj['distances']

    nedges = {}
    for k in edges:
        nedges[int(k)] = edges[k]
    edges = nedges

    print(edges[0])
    print(min(distances))
    print(max(distances))

    start = 1250
    d1 = data[start]
    for i in range(0, len(data)):
        d2 = data[i]
        distances[i] = len(hf.attacks.collision.metric.loose.delta_alt(48, d1, d2))

    print(indices)
    print(data[0] == bases['schlaffers'])
    assert('schlaffers' in indices)

    pdist = [9999]*len(data)
    pdist[start] = 0
    pq = []
    pq.append(start)

    while len(pq) > 0:
        u = pq[0]
        pq = pq[1:]
        for v in edges[u]:
            d_v = pdist[u] + 1
            if d_v < pdist[v]:
                pdist[v] = d_v
                pq.append(v)

    print(min(pdist))
    print(max(pdist))
    mdist = 6
    pmdist = 999999
    pmdi = 1
    for i in range(0, len(data)):
        if distances[i] == mdist and pdist[i] < 9999:
            if pdist[i] < pmdist:
                pmdist = pdist[i]
                pmdi = i

    print((mdist, pmdist, pmdi))

def find_path():
    f = open(JSON, 'r')
    obj = json.load(f)
    f.close()

    data = obj['data']
    edges = obj['edges']
    bases = obj['bases']
    indices = obj['indices']
    distances = obj['distances']

    nedges = {}
    for k in edges:
        nedges[int(k)] = edges[k]
    edges = nedges

    print(edges[0])
    print(min(distances))
    print(max(distances))


    start = 1250
    end = 1289

    d1 = data[start]
    for i in range(0, len(data)):
        d2 = data[i]
        distances[i] = len(hf.attacks.collision.metric.loose.delta_alt(48, d1, d2))

    print(distances[end])

    pdist = [9999]*len(data)
    pdist[start] = 0
    pq = []
    pq.append(start)
    parents = {}

    while len(pq) > 0:
        u = pq[0]
        pq = pq[1:]
        for v in edges[u]:
            d_v = pdist[u] + 1
            if d_v < pdist[v]:
                pdist[v] = d_v
                pq.append(v)
                parents[v] = u

    print(end)
    print(parents[end])
    print(parents[parents[end]])
    print(parents[parents[parents[end]]])
    print(parents[parents[parents[parents[end]]]])
    print(parents[parents[parents[parents[parents[end]]]]])
    print(parents[parents[parents[parents[parents[parents[end]]]]]])

def scaleArray(m, sf):
    r = []
    h = len(m)*sf
    w = len(m[0])*sf
    for i in range(0, h):
        r.append([0] * w)
    for i in range(0, h):
        for j in range(0, w):
            x = i//sf
            y = j//sf
            r[i][j] = m[x][y]
    return r


def draw_differential(differential, out_name):
    #7C2529
    dot_color = (0xF1, 0xBE, 0x48)
    star_color = (0x7C, 0x25, 0x29)

    background_color = (0xFF, 0xFF, 0xFF)

    box_width = 12*4
    box_height = 12
    padding = 12

    width = box_width*len(differential) + padding*(len(differential) - 1)
    height = box_height*len(differential[0])
    arr = []
    for i in range(0, height):
        na = []
        for j in range(0, width):
            na.append(background_color)
        arr.append(na)

    x = 0
    y = 0

    for i in differential:
        for j in i:
            for v in range(x, x+box_width):
                for w in range(y, y+box_height):
                    if j == '.':
                        arr[w][v] = dot_color
                    elif j == '*':
                        arr[w][v] = star_color
            y += box_height
        y = 0
        x += box_width
        x += padding

    png.from_array(arr, 'RGB').save(out_name)




def write_differentials():
    f = open(JSON, 'r')
    obj = json.load(f)
    f.close()

    data = obj['data']
    edges = obj['edges']
    bases = obj['bases']
    indices = obj['indices']
    distances = obj['distances']

    nedges = {}
    for k in edges:
        nedges[int(k)] = edges[k]
    edges = nedges

    path = [1289, 445, 74, 0, 2, 101, 1250]
    for i in path:
        print(data[i])
        draw_differential(data[i], "/tmp/differential-" + str(i) + ".png")

    for i in range(1, len(path)):
        a = path[i-1]
        b = path[i]
        p = hf.attacks.collision.metric.loose.delta_alt(48, data[a], data[b])[0]
        print((a, b, p, data[a][p], data[b][p]))

# write_data()
# max_radius()
# find_longest_path()
# find_path()
# write_differentials()
